{"pageProps":{"data":{"slug":"0-introduction","frontMatter":{"id":0,"title":"1. Introduction","category":"Typescript Decorator","language":"Typescript","difficulty":"Medium","source":null,"source_url":null,"created_at":"2024-02-29","updated_at":"2024-03-05","is_playground":false,"is_comment":false},"content":"Decorators are a special type of declaration that can be attached to class declarations, methods, accessors, properties, or parameters. Decorators use the `@expression` form, where `expression` must evaluate to a function. It is called at runtime, with the decorated declaration information passed as a parameter. Decorators are generally used to handle logic unrelated to the class or its properties. For example, measuring the execution time of a class method or logging can be written as a separate decorator. In Node.js, a framework that uses decorators well is NestJS. However, if you are not familiar with it, it's okay. I will explain the use of decorators according to my understanding. To enable the decorator feature, please enable the `experimentalDecorators` compiler option in `tsconfig.json`.\nDocument in this article is based on [decorators](https://www.typescriptlang.org/docs/handbook/decorators.html), but examples are written in a way which could be used in nestjs.\n\n## Quick Start\n\nSometimes, we may need to perform type checking on incoming parameters, sort and filter return values, add throttling and debouncing to functions, or other functional code based on multiple class inheritances. There are various repetitive codes that are unrelated to the logic of the function itself. For example, we want to record the login time when a user logs in.\n\n```typescript\nconst logger = (now: number) => console.log(`lasted logged in ${now}`);\n\nclass User {\n  async login() {\n    await setTimeout(() => console.log('login success'), 100);\n    logger(new Date().valueOf());\n  }\n}\n```\n\nThe above code forcibly writes the code for logging into the login logic processing, so the higher the code volume, the more redundant the code. We need to separate the logging logic and make the *login* method more focused on handling the login logic. Next, we will simulate the principle of decorators using higher-order functions to better understand decorators later.\n\n```typescript\n/**\n * Use higher-order functions\n * Currying to destructure login and log recording\n */\n\ntype DecoratorFunc = (\n  target: any,\n  key: string,\n  descriptor: PropertyDescriptor\n) => void;\n\n// Simulated decorator factory function\nconst createDecorator =\n  (decorator: DecoratorFunc) => (Model: any, key: string) => {\n    // Get the class prototype that will use the decorator\n    const target = Model.prototype;\n    // Get the description of a method on this prototype.\n    const descriptor = Object.getOwnPropertyDescriptor(target, key);\n    // Change description,generate new method\n    decorator(target, key, descriptor);\n  };\n\nconst logger: DecoratorFunc = (target, key, descriptor) =>\n  // Redefine the modified function to the prototype chain\n  Object.defineProperty(target, key, {\n    ...descriptor,\n    value: async (...args: any[]) => {\n      try {\n        return descriptor.value.apply(this, args); // Call the previous function.\n      } finally {\n        const now = new Date().valueOf();\n        console.log(`lasted logged in ${now}`);\n      }\n    },\n  });\n\nclass User {\n  async login() {\n    console.log('login success');\n    await new Promise((resolve) => {\n      setTimeout(resolve, 100);\n    });\n  }\n}\n\nexport const exp1 = () => {\n  console.log();\n  console.log(\n    '-----------------------Login and Logging Decoupling-----------------------'\n  );\n  console.log();\n  const loggerDecorator = createDecorator(logger);\n  loggerDecorator(User, 'login');\n  const user = new User();\n  user.login();\n  console.log();\n  console.log('-----------------------End-----------------------');\n};\n\n// console\n// login success\n// Pause for 100ms.\n// lasted logged in 1571771681793\n```\n\n## Decorator types\n\nThere are several types of decorators in <b>Typescript</b>:\n\n*   Class decorators\n*   Property decorators\n*   Method decorators\n*   Parameter decorators\n*   Accessor decorators\n\nEach of these decorators can work on the class prototype (*prototype* attribute) and the class itself, respectively\n\nAfter understanding the above concepts, let's move on to learning about the real decorators.\n","props":{"readingTimeMinutes":1,"description":"Decorators are a special type of declaration that can be attached to class declarations, methods,..."}},"prev":null,"next":{"title":"2. Class Decorator","href":"/learn/typescript-decorator/1-class-decorator"}},"__N_SSG":true}