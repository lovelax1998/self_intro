{"pageProps":{"data":{"slug":"3-method-decorator","frontMatter":{"id":3,"title":"4. Method Decorator","category":"Typescript Decorator","language":"Typescript","difficulty":"Medium","source":null,"source_url":null,"created_at":"2024-03-05","updated_at":"2024-03-05","is_playground":false,"is_comment":false},"content":"At the beginning, we introduced the principle of decorators, which is actually the original implementation of method decorators. Unlike property decorators, method decorators accept three parameters.\n\n> One thing to note when overloading method decorators is that the value must be defined using a function, not an arrow function. This is because we use this when calling the original old method, such as method.apply(this, args), and the this here needs to be defined using a function.\n\n## Parameters\n\n**target** For static members, it is the constructor of the class; for instance members, it is the prototype object of the class. **key** The name of the method. **descriptor: PropertyDescriptor** The property descriptor of the method (the most important parameter).\n\n## Attribute descriptor\n\nThe attribute description includes the following attributes:\n\n*   *configurable?: boolean;* Whether it can be deleted, whether method characteristics can be modified, or whether accessor properties can be modified.\n\n*   *enumerable?: boolean;* Whether it exists when iterating through objects.\n\n*   *value?: any;* Used to define a new method to replace the old method.\n\n*   *writable?: boolean;* Whether it is writable.\n\n*   *get?(): any;* Accessor.\n\n*   *set?(v: any): void;* Accessor.\n\nNext, we use method decorators to modify the login logger in the original decorator principle.\n\n```typescript\nconst loggerDecorator = () => {\n    return function logMethod(\n        target: any,\n        propertyName: string,\n        propertyDescriptor: PropertyDescriptor,\n    ): PropertyDescriptor {\n        const method = propertyDescriptor.value;\n\n        // Overloaded original method\n        propertyDescriptor.value = function async(...args: any[]) {\n            try {\n                return method.apply(this, args); // Call the original function.\n            } finally {\n                const now = new Date().valueOf();\n                console.log(`lasted logged in ${now}`);\n            }\n        };\n        return propertyDescriptor;\n    };\n};\n\nclass UserService {\n    @loggerDecorator()\n    async login() {\n        console.log('login success');\n        await new Promise((resolve) => {\n            setTimeout(resolve, 100);\n        });\n    }\n}\n\nexport const exp6 = () => {\n    console.log();\n    console.log(\n        '-----------------------Method Decorator-----------------------',\n    );\n    console.log(\n        '-----------------------Automatically print logs after invoke login.----------------------',\n    );\n    console.log();\n    const user = new UserService();\n    user.login();\n    console.log();\n    console.log('-----------------------End-----------------------');\n};\n\n// console\n// login success\n// Pause for 100ms.\n// lasted logged in 1571771681793\n```\n","props":{"readingTimeMinutes":1,"description":"At the beginning, we introduced the principle of decorators, which is actually the original..."}},"prev":{"title":"3. Property Decorator","href":"/learn/typescript-decorator/2-property-decorator"},"next":{"title":"5. Parameter Decorator","href":"/learn/typescript-decorator/4-parameter-decorator"}},"__N_SSG":true}