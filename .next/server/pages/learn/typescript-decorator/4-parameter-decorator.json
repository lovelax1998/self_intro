{"pageProps":{"data":{"slug":"4-parameter-decorator","frontMatter":{"id":4,"title":"5. Parameter Decorator","category":"Typescript Decorator","language":"Typescript","difficulty":"Medium","source":null,"source_url":null,"created_at":"2024-03-05","updated_at":"2024-03-05","is_playground":false,"is_comment":false},"content":"Each method in a class can also have its own decorators.\n\n> Similar to property decorators, parameter decorators are generally not used alone, but are used in combination with class or method decorators.\n\n## Parameters\n\n1.  *target* is the constructor of the class for static members, and the prototype object of the class for instance members.\n\n2.  *key* method name\n\n3.  *index* position in the parameter array\n\nFor example, if we need to format the parameters of a method, we can create a decorator specifically for formatting.\n\n```typescript\n// Parameter formatting configuration\nconst parseConf: ((...args: any[]) => any)[] = [];\n\nexport const parse =\n    (parseTo: (...args: any[]) => any) =>\n    (target: any, propertyName: string, index: number) => {\n        parseConf[index] = parseTo;\n    };\n\n// Perform formatting operations before function call.\nexport const parseDecorator = (\n    target: any,\n    propertyName: string,\n    descriptor: PropertyDescriptor,\n): PropertyDescriptor => {\n    console.log('Start formatting data.');\n    return {\n        ...descriptor,\n        value(...args: any[]) {\n            // Get the formatted parameter list.\n            const newArgs = args.map((v, i) =>\n                parseConf[i] ? parseConf[i](v) : v,\n            );\n            console.log('Finished formatting data.');\n            return descriptor.value.apply(this, newArgs);\n        },\n    };\n};\n\nexport interface UserType {\n    id: number;\n    username: string;\n}\n\nclass UserService {\n    private users: UserType[] = [\n        { id: 1, username: 'admin' },\n        { id: 2, username: 'brian' },\n    ];\n\n    getUsers() {\n        return this.users;\n    }\n\n    @parseDecorator\n    delete(@parse((arg: any) => Number(arg)) id: number) {\n        this.users = this.users.filter((userObj) => userObj.id !== id);\n        return this;\n    }\n}\n\nexport const exp78 = () => {\n    console.log();\n    console.log(\n        '-----------------------Parameter decorator--------------------',\n    );\n    console.log('---------------Formatting parameters-----------------');\n    console.log();\n    const userService = new UserService();\n    userService.delete(1);\n    console.log(userService.getUsers());\n    console.log();\n    console.log('---------------End-----------------------');\n};\n\n\n// console: [ { id: 2, username: 'brian' } ]\n```\n","props":{"readingTimeMinutes":1,"description":"Each method in a class can also have its own decorators.\n\n> Similar to property decorators,..."}},"prev":{"title":"4. Method Decorator","href":"/learn/typescript-decorator/3-method-decorator"},"next":{"title":"6. Accessor Decorator","href":"/learn/typescript-decorator/5-accessor-decorator"}},"__N_SSG":true}