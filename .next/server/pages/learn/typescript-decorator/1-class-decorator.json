{"pageProps":{"data":{"slug":"1-class-decorator","frontMatter":{"id":1,"title":"2. Class Decorator","category":"Typescript Decorator","language":"Typescript","difficulty":"Medium","source":null,"source_url":null,"created_at":"2024-02-29","updated_at":"2024-02-29","is_playground":false,"is_comment":false},"content":"## Class decorator\n\n[Official TS Docs](https://www.typescriptlang.org/docs/handbook/decorators.html) provide an example of a class decorator that you can look at, too. Class decorators just pass our original class into the decorator annotation to process the class or the class prototype. That's it.\n\n```typescript\nconst HelloDerorator = <T extends new (...args: any[]) => any>(\n    constructor: T,\n) => {\n    return class extends constructor {\n        newProperty = 'new property';\n        hello = 'override';\n        sayHello() {\n            return this.hello;\n        }\n    };\n};\n\n@HelloDerorator\nexport class Hello {\n    [key: string]: any; // This is used to prevent eslint from prompting that the sayHello method does not exist\n    hello: string;\n    constructor() {\n        this.hello = 'test';\n    }\n}\n\nconst exp2 = () => {\n    console.log(\n        '-----------------------Simple Class Decorators-----------------------',\n    );\n    console.log(\n        '-----------------------Dynamically add a sayHello method and override the value of hello.-----------------------',\n    );\n    console.log();\n    const hello = new Hello();\n    console.log(hello.sayHello());\n    console.log();\n    console.log('-----------------------End-----------------------');\n};\n\n\n// console override\n```\n\n## Decorator Factory\n\nThe above method adds a `HelloDerorator` decorator to the `UserService`, and the properties of this decorator will override the default properties of the `UserService`. In order to conveniently add other parameters to the decorator, we transform `HelloDerorator` into a decorator factory as follows:\n\n```typescript\nconst SetNameDecorator = (firstname: string, lastname: string) => {\n    const name = `${firstname}.${lastname}`;\n    return <T extends new (...args: any[]) => any>(target: T) => {\n        return class extends target {\n            _name: string = name;\n\n            getMyName() {\n                return this._name;\n            }\n        };\n    };\n};\n\n@SetNameDecorator('Brian', 'Shen')\nclass UserService {\n    c() {}\n}\n\nconst exp3 = () => {\n    console.log();\n    console.log(\n        '-----------------------Decorator Factory-----------------------',\n    );\n    console.log(\n        '-----------------------Override the getName method through inheritance-----------------------',\n    );\n    console.log();\n    const user = new UserService();\n    console.log(user.getMyName());\n    console.log();\n    console.log('-----------------------End-----------------------');\n};\n\n// console Brian.Shen\n```\n\n## Other usages\n\nWe can also assign or override properties or methods on the class prototype chain `prototype`, as well as static properties and methods of the class itself. We can also overload the constructor function.\n\n```typescript\ntype UserProfile = Record<string, any> & {\n    phone?: number;\n    address?: string;\n};\n\nconst ProfileDecorator = (profile: UserProfile) => (target: any) => {\n    const Original = target;\n    let userinfo = '';\n    Object.keys(profile).forEach((key) => {\n        userinfo = `${userinfo}.${profile[key].toString()}`;\n    });\n    // Add a prototype property\n    Original.prototype.userinfo = userinfo;\n    // Use a function to create a new class (class constructor), with the return value being an object of the passed-in class, thus overloading the constructor.\n    function constructor(...args: any[]) {\n        console.log('contruct has been changed');\n        return new Original(...args);\n    }\n    // Assignment of prototypes\n    constructor.prototype = Original.prototype;\n    // Add a static property\n    constructor.myinfo = `myinfo ${userinfo}`;\n    return constructor as typeof Original;\n};\n\n// ecause static properties cannot obtain type prompts through [key: string]: any;, an interface is added here to dynamically add static properties of various types\ninterface StaticUser {\n    new (): UserProfile;\n    myinfo: string;\n}\n\n@ProfileDecorator({ phone: 133, address: 'zhejiang' })\nclass ProfileService {}\n\nconst exp4 = () => {\n    console.log();\n    console.log(\n        '-----------------------The construction function, prototype properties, static properties, etc. of the repair class.-----------------------',\n    );\n    console.log(\n        '-----------------------Set prototype property values, overload constructor methods, add static properties.-----------------------',\n    );\n    console.log();\n    console.log((ProfileService as unknown as StaticUser).myinfo);\n    const profile = new ProfileService();\n    console.log((profile as any).userinfo);\n    console.log();\n    console.log('-----------------------End-----------------------');\n};\nexp4();\n// console myinfo .133.zhejiang\n// console contruct has been changed\n// console .133.zhejiang\n```\n","props":{"readingTimeMinutes":1,"description":"## Class decorator\n\n[Official TS..."}},"prev":{"title":"1. Introduction","href":"/learn/typescript-decorator/0-introduction"},"next":{"title":"3. Property Decorator","href":"/learn/typescript-decorator/2-property-decorator"}},"__N_SSG":true}